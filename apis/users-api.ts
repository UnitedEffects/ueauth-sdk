/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccountPanicBody } from '../models';
import { DefaultError } from '../models';
import { GetAccount } from '../models';
import { GetAccounts } from '../models';
import { ImportAccount } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse2004 } from '../models';
import { InlineResponse2005 } from '../models';
import { InlineResponse2006 } from '../models';
import { InlineResponse201 } from '../models';
import { InlineResponse2011 } from '../models';
import { RecoverAccountRequest } from '../models';
import { RecoverAccountResponse } from '../models';
import { RecoveryRequestObject } from '../models';
import { WriteAccount } from '../models';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This request will completely remove the unique Account from the AuthGroup. You should be careful with this method as it may lead to unforeseen data states such as orphaned records if you have tightly integrated with this API.
         * @summary Hard delete a user
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling deleteAccount.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/api/{group}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup any AuthGroups a user owns. Must be a root user or Notifications must be on so an email can be sent to the user.
         * @summary Lookup any AuthGroups a user owns
         * @param {string} lookup the email address of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountGroups: async (lookup: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lookup' is not null or undefined
            if (lookup === null || lookup === undefined) {
                throw new RequiredError('lookup','Required parameter lookup was null or undefined when calling findAccountGroups.');
            }
            const localVarPath = `/api/account/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (lookup !== undefined) {
                localVarQueryParameter['lookup'] = lookup;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Identify a single user by their user ID. If you enter \"me\" in the ID field, it will return your own information.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getAccount.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAccount.');
            }
            const localVarPath = `/api/{group}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return every Account (user) associated to the Auth Group.
         * @summary Retrieve all users in the Auth Group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/api/{group}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (filter !== undefined) {
                localVarQueryParameter['$filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['$select'] = select;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['$orderby'] = orderby;
            }

            if (skip !== undefined) {
                localVarQueryParameter['$skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['$top'] = top;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to import an array of users to the Auth Group independant of any organization or other access considerations. This API cannot be used for self-registration. Passwords are automatically generated and all users must claim their accounts. No profile data can be added with this API.
         * @summary Import users to the Auth Group
         * @param {Array<ImportAccount>} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAccounts: async (body: Array<ImportAccount>, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling importAccounts.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling importAccounts.');
            }
            const localVarPath = `/api/{group}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If a user notices unusual activity, they can immediately lock their account. This action requires recovery codes to undo. If the user has not generated recovery codes, they will need to contact an administrator for assistance. This action will also kill all active sessions for the user. PLEASE NOTE, if JWT tokens have been issued for the account, this will not disable them. Always ensure that Access Tokens have reasonable expiration times to avoid issues with locked accounts and live active JWT tokens.
         * @summary Immediately Lock an Account
         * @param {string} group the auth group ID associated to your business account
         * @param {AccountPanicBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockMyAccount: async (group: string, body?: AccountPanicBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling lockMyAccount.');
            }
            const localVarPath = `/api/{group}/account/panic`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This allows you to update an Account record. While there is a permission to allow administrators of the AuthGroup to do this, it is recommended that you typically allow users themselves to manage their information unless they request assistance.
         * @summary Patch an existing User
         * @param {Array<any>} body JSON Patch specific to your account object
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccount: async (body: Array<any>, group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchAccount.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling patchAccount.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchAccount.');
            }
            const localVarPath = `/api/{group}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Using the token from \"start-recovery\", you can unlock the account and set a new password. Optionally, you can set a random strong password.
         * @summary Unlock an Account and Reset Password
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoverAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverAccount: async (group: string, body?: RecoverAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling recoverAccount.');
            }
            const localVarPath = `/api/{group}/account/recover`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup
         * @param {string} group the auth group ID associated to your business account
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (group: string, q: string, restrictEmail?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling searchAccounts.');
            }
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchAccounts.');
            }
            const localVarPath = `/api/{group}/accounts/search`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (restrictEmail !== undefined) {
                localVarQueryParameter['restrictEmail'] = restrictEmail;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This API will allow a user to recovery their account after locking using their recovery codes. If the request is successful, this API returns a bearer token to be used in the actual recovery. The API will also set a state cookie as part of the response to ensure the second recovery request is from the same device.
         * @summary Initiate Recovery of Locked Account
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoveryRequestObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery: async (group: string, body?: RecoveryRequestObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling startRecovery.');
            }
            const localVarPath = `/api/{group}/account/start-recovery`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user to an Auth Group independant of any organization or other access considerations. Self-registration is possible if the Auth Group has defined locked=false. Otherwise, an appropriately permissioned member of the Auth Group must create the user. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email (and creat/modify/active meta data) of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner; however, if you supply profile information, a secured profile record will be generated which the account holder can administrate later.
         * @summary Register a new user
         * @param {WriteAccount} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeAccount: async (body: WriteAccount, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling writeAccount.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling writeAccount.');
            }
            const localVarPath = `/api/{group}/account`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Recovery codes are 10 hashed strings that are only ever displayed when the user generates them. In the event of an account lockout, they can be used to restore access and reset password should no other option be available. If lost, they must be reset. They cannot be updated and hitting this endpoint more than once will reset them.
         * @summary Create Account Recovery Codes
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeRecoveryCodes: async (group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling writeRecoveryCodes.');
            }
            const localVarPath = `/api/{group}/account/codes`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This request will completely remove the unique Account from the AuthGroup. You should be careful with this method as it may lead to unforeseen data states such as orphaned records if you have tightly integrated with this API.
         * @summary Hard delete a user
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccount>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteAccount(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lookup any AuthGroups a user owns. Must be a root user or Notifications must be on so an email can be sent to the user.
         * @summary Lookup any AuthGroups a user owns
         * @param {string} lookup the email address of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountGroups(lookup: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2003>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).findAccountGroups(lookup, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Identify a single user by their user ID. If you enter \"me\" in the ID field, it will return your own information.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccount>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getAccount(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will return every Account (user) associated to the Auth Group.
         * @summary Retrieve all users in the Auth Group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccounts>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getAccounts(group, filter, select, orderby, skip, top, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API allows you to import an array of users to the Auth Group independant of any organization or other access considerations. This API cannot be used for self-registration. Passwords are automatically generated and all users must claim their accounts. No profile data can be added with this API.
         * @summary Import users to the Auth Group
         * @param {Array<ImportAccount>} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importAccounts(body: Array<ImportAccount>, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2011>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).importAccounts(body, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a user notices unusual activity, they can immediately lock their account. This action requires recovery codes to undo. If the user has not generated recovery codes, they will need to contact an administrator for assistance. This action will also kill all active sessions for the user. PLEASE NOTE, if JWT tokens have been issued for the account, this will not disable them. Always ensure that Access Tokens have reasonable expiration times to avoid issues with locked accounts and live active JWT tokens.
         * @summary Immediately Lock an Account
         * @param {string} group the auth group ID associated to your business account
         * @param {AccountPanicBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockMyAccount(group: string, body?: AccountPanicBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).lockMyAccount(group, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This allows you to update an Account record. While there is a permission to allow administrators of the AuthGroup to do this, it is recommended that you typically allow users themselves to manage their information unless they request assistance.
         * @summary Patch an existing User
         * @param {Array<any>} body JSON Patch specific to your account object
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccount(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccount>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).patchAccount(body, group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Using the token from \"start-recovery\", you can unlock the account and set a new password. Optionally, you can set a random strong password.
         * @summary Unlock an Account and Reset Password
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoverAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverAccount(group: string, body?: RecoverAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RecoverAccountResponse>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).recoverAccount(group, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup
         * @param {string} group the auth group ID associated to your business account
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(group: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2004>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).searchAccounts(group, q, restrictEmail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API will allow a user to recovery their account after locking using their recovery codes. If the request is successful, this API returns a bearer token to be used in the actual recovery. The API will also set a state cookie as part of the response to ensure the second recovery request is from the same device.
         * @summary Initiate Recovery of Locked Account
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoveryRequestObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(group: string, body?: RecoveryRequestObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).startRecovery(group, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Register a new user to an Auth Group independant of any organization or other access considerations. Self-registration is possible if the Auth Group has defined locked=false. Otherwise, an appropriately permissioned member of the Auth Group must create the user. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email (and creat/modify/active meta data) of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner; however, if you supply profile information, a secured profile record will be generated which the account holder can administrate later.
         * @summary Register a new user
         * @param {WriteAccount} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeAccount(body: WriteAccount, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse201>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).writeAccount(body, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Recovery codes are 10 hashed strings that are only ever displayed when the user generates them. In the event of an account lockout, they can be used to restore access and reset password should no other option be available. If lost, they must be reset. They cannot be updated and hitting this endpoint more than once will reset them.
         * @summary Create Account Recovery Codes
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeRecoveryCodes(group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).writeRecoveryCodes(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This request will completely remove the unique Account from the AuthGroup. You should be careful with this method as it may lead to unforeseen data states such as orphaned records if you have tightly integrated with this API.
         * @summary Hard delete a user
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccount>> {
            return UsersApiFp(configuration).deleteAccount(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup any AuthGroups a user owns. Must be a root user or Notifications must be on so an email can be sent to the user.
         * @summary Lookup any AuthGroups a user owns
         * @param {string} lookup the email address of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountGroups(lookup: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2003>> {
            return UsersApiFp(configuration).findAccountGroups(lookup, options).then((request) => request(axios, basePath));
        },
        /**
         * Identify a single user by their user ID. If you enter \"me\" in the ID field, it will return your own information.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccount>> {
            return UsersApiFp(configuration).getAccount(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return every Account (user) associated to the Auth Group.
         * @summary Retrieve all users in the Auth Group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccounts>> {
            return UsersApiFp(configuration).getAccounts(group, filter, select, orderby, skip, top, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to import an array of users to the Auth Group independant of any organization or other access considerations. This API cannot be used for self-registration. Passwords are automatically generated and all users must claim their accounts. No profile data can be added with this API.
         * @summary Import users to the Auth Group
         * @param {Array<ImportAccount>} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importAccounts(body: Array<ImportAccount>, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2011>> {
            return UsersApiFp(configuration).importAccounts(body, group, options).then((request) => request(axios, basePath));
        },
        /**
         * If a user notices unusual activity, they can immediately lock their account. This action requires recovery codes to undo. If the user has not generated recovery codes, they will need to contact an administrator for assistance. This action will also kill all active sessions for the user. PLEASE NOTE, if JWT tokens have been issued for the account, this will not disable them. Always ensure that Access Tokens have reasonable expiration times to avoid issues with locked accounts and live active JWT tokens.
         * @summary Immediately Lock an Account
         * @param {string} group the auth group ID associated to your business account
         * @param {AccountPanicBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockMyAccount(group: string, body?: AccountPanicBody, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return UsersApiFp(configuration).lockMyAccount(group, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This allows you to update an Account record. While there is a permission to allow administrators of the AuthGroup to do this, it is recommended that you typically allow users themselves to manage their information unless they request assistance.
         * @summary Patch an existing User
         * @param {Array<any>} body JSON Patch specific to your account object
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of account to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccount(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccount>> {
            return UsersApiFp(configuration).patchAccount(body, group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Using the token from \"start-recovery\", you can unlock the account and set a new password. Optionally, you can set a random strong password.
         * @summary Unlock an Account and Reset Password
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoverAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverAccount(group: string, body?: RecoverAccountRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<RecoverAccountResponse>> {
            return UsersApiFp(configuration).recoverAccount(group, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup
         * @param {string} group the auth group ID associated to your business account
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(group: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2004>> {
            return UsersApiFp(configuration).searchAccounts(group, q, restrictEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * This API will allow a user to recovery their account after locking using their recovery codes. If the request is successful, this API returns a bearer token to be used in the actual recovery. The API will also set a state cookie as part of the response to ensure the second recovery request is from the same device.
         * @summary Initiate Recovery of Locked Account
         * @param {string} group the auth group ID associated to your business account
         * @param {RecoveryRequestObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(group: string, body?: RecoveryRequestObject, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2006>> {
            return UsersApiFp(configuration).startRecovery(group, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user to an Auth Group independant of any organization or other access considerations. Self-registration is possible if the Auth Group has defined locked=false. Otherwise, an appropriately permissioned member of the Auth Group must create the user. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email (and creat/modify/active meta data) of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner; however, if you supply profile information, a secured profile record will be generated which the account holder can administrate later.
         * @summary Register a new user
         * @param {WriteAccount} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeAccount(body: WriteAccount, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse201>> {
            return UsersApiFp(configuration).writeAccount(body, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Recovery codes are 10 hashed strings that are only ever displayed when the user generates them. In the event of an account lockout, they can be used to restore access and reset password should no other option be available. If lost, they must be reset. They cannot be updated and hitting this endpoint more than once will reset them.
         * @summary Create Account Recovery Codes
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeRecoveryCodes(group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return UsersApiFp(configuration).writeRecoveryCodes(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * This request will completely remove the unique Account from the AuthGroup. You should be careful with this method as it may lead to unforeseen data states such as orphaned records if you have tightly integrated with this API.
     * @summary Hard delete a user
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of account type to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async deleteAccount(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccount>> {
        return UsersApiFp(this.configuration).deleteAccount(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lookup any AuthGroups a user owns. Must be a root user or Notifications must be on so an email can be sent to the user.
     * @summary Lookup any AuthGroups a user owns
     * @param {string} lookup the email address of a person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async findAccountGroups(lookup: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2003>> {
        return UsersApiFp(this.configuration).findAccountGroups(lookup, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Identify a single user by their user ID. If you enter \"me\" in the ID field, it will return your own information.
     * @summary Find a User with ID
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of account type to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async getAccount(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccount>> {
        return UsersApiFp(this.configuration).getAccount(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will return every Account (user) associated to the Auth Group.
     * @summary Retrieve all users in the Auth Group
     * @param {string} group the auth group ID associated to your business account
     * @param {string} [filter] oData filter Query
     * @param {string} [select] oData select Query
     * @param {string} [orderby] oData orderby Query
     * @param {string} [skip] oData skip Query
     * @param {string} [top] oData top Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async getAccounts(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccounts>> {
        return UsersApiFp(this.configuration).getAccounts(group, filter, select, orderby, skip, top, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This API allows you to import an array of users to the Auth Group independant of any organization or other access considerations. This API cannot be used for self-registration. Passwords are automatically generated and all users must claim their accounts. No profile data can be added with this API.
     * @summary Import users to the Auth Group
     * @param {Array<ImportAccount>} body Account data to be written
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async importAccounts(body: Array<ImportAccount>, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2011>> {
        return UsersApiFp(this.configuration).importAccounts(body, group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If a user notices unusual activity, they can immediately lock their account. This action requires recovery codes to undo. If the user has not generated recovery codes, they will need to contact an administrator for assistance. This action will also kill all active sessions for the user. PLEASE NOTE, if JWT tokens have been issued for the account, this will not disable them. Always ensure that Access Tokens have reasonable expiration times to avoid issues with locked accounts and live active JWT tokens.
     * @summary Immediately Lock an Account
     * @param {string} group the auth group ID associated to your business account
     * @param {AccountPanicBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async lockMyAccount(group: string, body?: AccountPanicBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return UsersApiFp(this.configuration).lockMyAccount(group, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This allows you to update an Account record. While there is a permission to allow administrators of the AuthGroup to do this, it is recommended that you typically allow users themselves to manage their information unless they request assistance.
     * @summary Patch an existing User
     * @param {Array<any>} body JSON Patch specific to your account object
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of account to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async patchAccount(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccount>> {
        return UsersApiFp(this.configuration).patchAccount(body, group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Using the token from \"start-recovery\", you can unlock the account and set a new password. Optionally, you can set a random strong password.
     * @summary Unlock an Account and Reset Password
     * @param {string} group the auth group ID associated to your business account
     * @param {RecoverAccountRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async recoverAccount(group: string, body?: RecoverAccountRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<RecoverAccountResponse>> {
        return UsersApiFp(this.configuration).recoverAccount(group, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to search accounts in the authgroup using a text search
     * @summary Search Accounts in the authGroup
     * @param {string} group the auth group ID associated to your business account
     * @param {string} q keyword search
     * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async searchAccounts(group: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2004>> {
        return UsersApiFp(this.configuration).searchAccounts(group, q, restrictEmail, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This API will allow a user to recovery their account after locking using their recovery codes. If the request is successful, this API returns a bearer token to be used in the actual recovery. The API will also set a state cookie as part of the response to ensure the second recovery request is from the same device.
     * @summary Initiate Recovery of Locked Account
     * @param {string} group the auth group ID associated to your business account
     * @param {RecoveryRequestObject} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async startRecovery(group: string, body?: RecoveryRequestObject, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2006>> {
        return UsersApiFp(this.configuration).startRecovery(group, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register a new user to an Auth Group independant of any organization or other access considerations. Self-registration is possible if the Auth Group has defined locked=false. Otherwise, an appropriately permissioned member of the Auth Group must create the user. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email (and creat/modify/active meta data) of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner; however, if you supply profile information, a secured profile record will be generated which the account holder can administrate later.
     * @summary Register a new user
     * @param {WriteAccount} body Account data to be written
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async writeAccount(body: WriteAccount, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse201>> {
        return UsersApiFp(this.configuration).writeAccount(body, group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Recovery codes are 10 hashed strings that are only ever displayed when the user generates them. In the event of an account lockout, they can be used to restore access and reset password should no other option be available. If lost, they must be reset. They cannot be updated and hitting this endpoint more than once will reset them.
     * @summary Create Account Recovery Codes
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public async writeRecoveryCodes(group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return UsersApiFp(this.configuration).writeRecoveryCodes(group, options).then((request) => request(this.axios, this.basePath));
    }
}
