/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DefaultError } from '../models';
import { InlineResponse20020 } from '../models';
import { WriteClientAccess } from '../models';
/**
 * ClientAccessApi - axios parameter creator
 * @export
 */
export const ClientAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API associates a Product and Roles to the client. It will also update the associatedClients object of the Product in question.
         * @summary Add a Product and Roles to a Client so that it can act with permissions using a client_credential token
         * @param {WriteClientAccess} body Account data to be written
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyClientAccess: async (body: WriteClientAccess, group: string, id: string, product: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling applyClientAccess.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling applyClientAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling applyClientAccess.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling applyClientAccess.');
            }
            const localVarPath = `/api/{group}/access/client/{id}/product/{product}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API returns the defined access of a specified client and product combination.
         * @summary Return the product and roles associated to a client
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAccess: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getClientAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClientAccess.');
            }
            const localVarPath = `/api/{group}/access/client/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API removes that access by deleting the product and associated roles form the Client's access object. This will NOT remove the client ID from the associatedClients array of the product object.
         * @summary Completely dissassociate a product from the client and remove the attributed roles
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClientAccess: async (group: string, id: string, product: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling removeClientAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeClientAccess.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling removeClientAccess.');
            }
            const localVarPath = `/api/{group}/access/client/{id}/product/{product}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientAccessApi - functional programming interface
 * @export
 */
export const ClientAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API associates a Product and Roles to the client. It will also update the associatedClients object of the Product in question.
         * @summary Add a Product and Roles to a Client so that it can act with permissions using a client_credential token
         * @param {WriteClientAccess} body Account data to be written
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyClientAccess(body: WriteClientAccess, group: string, id: string, product: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20020>>> {
            const localVarAxiosArgs = await ClientAccessApiAxiosParamCreator(configuration).applyClientAccess(body, group, id, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API returns the defined access of a specified client and product combination.
         * @summary Return the product and roles associated to a client
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAccess(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20020>>> {
            const localVarAxiosArgs = await ClientAccessApiAxiosParamCreator(configuration).getClientAccess(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API removes that access by deleting the product and associated roles form the Client's access object. This will NOT remove the client ID from the associatedClients array of the product object.
         * @summary Completely dissassociate a product from the client and remove the attributed roles
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClientAccess(group: string, id: string, product: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20020>>> {
            const localVarAxiosArgs = await ClientAccessApiAxiosParamCreator(configuration).removeClientAccess(group, id, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClientAccessApi - factory interface
 * @export
 */
export const ClientAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API associates a Product and Roles to the client. It will also update the associatedClients object of the Product in question.
         * @summary Add a Product and Roles to a Client so that it can act with permissions using a client_credential token
         * @param {WriteClientAccess} body Account data to be written
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyClientAccess(body: WriteClientAccess, group: string, id: string, product: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20020>> {
            return ClientAccessApiFp(configuration).applyClientAccess(body, group, id, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API returns the defined access of a specified client and product combination.
         * @summary Return the product and roles associated to a client
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAccess(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20020>> {
            return ClientAccessApiFp(configuration).getClientAccess(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Clients can be associated with a single Product and assigned roles from that product. This API removes that access by deleting the product and associated roles form the Client's access object. This will NOT remove the client ID from the associatedClients array of the product object.
         * @summary Completely dissassociate a product from the client and remove the attributed roles
         * @param {string} group Auth Group Id or name
         * @param {string} id client_id
         * @param {string} product the id of the product associated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClientAccess(group: string, id: string, product: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20020>> {
            return ClientAccessApiFp(configuration).removeClientAccess(group, id, product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientAccessApi - object-oriented interface
 * @export
 * @class ClientAccessApi
 * @extends {BaseAPI}
 */
export class ClientAccessApi extends BaseAPI {
    /**
     * Clients can be associated with a single Product and assigned roles from that product. This API associates a Product and Roles to the client. It will also update the associatedClients object of the Product in question.
     * @summary Add a Product and Roles to a Client so that it can act with permissions using a client_credential token
     * @param {WriteClientAccess} body Account data to be written
     * @param {string} group Auth Group Id or name
     * @param {string} id client_id
     * @param {string} product the id of the product associated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessApi
     */
    public async applyClientAccess(body: WriteClientAccess, group: string, id: string, product: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20020>> {
        return ClientAccessApiFp(this.configuration).applyClientAccess(body, group, id, product, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Clients can be associated with a single Product and assigned roles from that product. This API returns the defined access of a specified client and product combination.
     * @summary Return the product and roles associated to a client
     * @param {string} group Auth Group Id or name
     * @param {string} id client_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessApi
     */
    public async getClientAccess(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20020>> {
        return ClientAccessApiFp(this.configuration).getClientAccess(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Clients can be associated with a single Product and assigned roles from that product. This API removes that access by deleting the product and associated roles form the Client's access object. This will NOT remove the client ID from the associatedClients array of the product object.
     * @summary Completely dissassociate a product from the client and remove the attributed roles
     * @param {string} group Auth Group Id or name
     * @param {string} id client_id
     * @param {string} product the id of the product associated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientAccessApi
     */
    public async removeClientAccess(group: string, id: string, product: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20020>> {
        return ClientAccessApiFp(this.configuration).removeClientAccess(group, id, product, options).then((request) => request(this.axios, this.basePath));
    }
}
