/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DefaultError } from '../models';
import { InlineResponse20029 } from '../models';
import { InlineResponse20030 } from '../models';
import { WriteDomain } from '../models';
/**
 * OrganizationDomainsApi - axios parameter creator
 * @export
 */
export const OrganizationDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Domains allow you to further refine access within the context of an Organization. Domains are used as the primary association mechanism of Products to Users. In other words, if you wish a User to have access to a product, that user must be added to a Domain which already has that Product associated (the property is called associatedOrgProducts). Only those Products associated to the parent Organization are available to be associated to a child Domain. Every Organization automatically has an Administrative Domain created to allow access to the UEAuth product. It is not recommended that you add users to this Domain other than those who you wish to manage users, domains and roles.
         * @summary Create a Domain in a specified Organizations
         * @param {WriteDomain} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: async (body: WriteDomain, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDomain.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createDomain.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling createDomain.');
            }
            const localVarPath = `/api/{group}/organizations/{org}/domains`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will hard delete your Domain. There are limits on delete when a domain has been associated to a user. You may need to remove users first.
         * @summary Delete a Domain
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: async (group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling deleteDomain.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling deleteDomain.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDomain.');
            }
            const localVarPath = `/api/{group}/organizations/{org}/domains/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single Domain from within an Organization
         * @summary Get Domain by ID
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: async (group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getDomain.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getDomain.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDomain.');
            }
            const localVarPath = `/api/{group}/organizations/{org}/domains/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Domains within an Organization
         * @summary Get all Domains by Organizations Id
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: async (group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getDomains.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getDomains.');
            }
            const localVarPath = `/api/{group}/organizations/{org}/domains`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (filter !== undefined) {
                localVarQueryParameter['$filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['$select'] = select;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['$orderby'] = orderby;
            }

            if (skip !== undefined) {
                localVarQueryParameter['$skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['$top'] = top;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Domain's data
         * @summary Update a Domain
         * @param {Array<any>} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain: async (body: Array<any>, group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDomain.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateDomain.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling updateDomain.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDomain.');
            }
            const localVarPath = `/api/{group}/organizations/{org}/domains/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationDomainsApi - functional programming interface
 * @export
 */
export const OrganizationDomainsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Domains allow you to further refine access within the context of an Organization. Domains are used as the primary association mechanism of Products to Users. In other words, if you wish a User to have access to a product, that user must be added to a Domain which already has that Product associated (the property is called associatedOrgProducts). Only those Products associated to the parent Organization are available to be associated to a child Domain. Every Organization automatically has an Administrative Domain created to allow access to the UEAuth product. It is not recommended that you add users to this Domain other than those who you wish to manage users, domains and roles.
         * @summary Create a Domain in a specified Organizations
         * @param {WriteDomain} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomain(body: WriteDomain, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
            const localVarAxiosArgs = await OrganizationDomainsApiAxiosParamCreator(configuration).createDomain(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will hard delete your Domain. There are limits on delete when a domain has been associated to a user. You may need to remove users first.
         * @summary Delete a Domain
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomain(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
            const localVarAxiosArgs = await OrganizationDomainsApiAxiosParamCreator(configuration).deleteDomain(group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a single Domain from within an Organization
         * @summary Get Domain by ID
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomain(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
            const localVarAxiosArgs = await OrganizationDomainsApiAxiosParamCreator(configuration).getDomain(group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all Domains within an Organization
         * @summary Get all Domains by Organizations Id
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomains(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20030>>> {
            const localVarAxiosArgs = await OrganizationDomainsApiAxiosParamCreator(configuration).getDomains(group, org, filter, select, orderby, skip, top, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Domain's data
         * @summary Update a Domain
         * @param {Array<any>} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomain(body: Array<any>, group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20029>>> {
            const localVarAxiosArgs = await OrganizationDomainsApiAxiosParamCreator(configuration).updateDomain(body, group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationDomainsApi - factory interface
 * @export
 */
export const OrganizationDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Domains allow you to further refine access within the context of an Organization. Domains are used as the primary association mechanism of Products to Users. In other words, if you wish a User to have access to a product, that user must be added to a Domain which already has that Product associated (the property is called associatedOrgProducts). Only those Products associated to the parent Organization are available to be associated to a child Domain. Every Organization automatically has an Administrative Domain created to allow access to the UEAuth product. It is not recommended that you add users to this Domain other than those who you wish to manage users, domains and roles.
         * @summary Create a Domain in a specified Organizations
         * @param {WriteDomain} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomain(body: WriteDomain, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
            return OrganizationDomainsApiFp(configuration).createDomain(body, group, org, options).then((request) => request(axios, basePath));
        },
        /**
         * This will hard delete your Domain. There are limits on delete when a domain has been associated to a user. You may need to remove users first.
         * @summary Delete a Domain
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomain(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
            return OrganizationDomainsApiFp(configuration).deleteDomain(group, org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single Domain from within an Organization
         * @summary Get Domain by ID
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomain(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
            return OrganizationDomainsApiFp(configuration).getDomain(group, org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Domains within an Organization
         * @summary Get all Domains by Organizations Id
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomains(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
            return OrganizationDomainsApiFp(configuration).getDomains(group, org, filter, select, orderby, skip, top, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Domain's data
         * @summary Update a Domain
         * @param {Array<any>} body Create a new role
         * @param {string} group Auth Group Id or name
         * @param {string} org organization id guid
         * @param {string} id domain id guid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomain(body: Array<any>, group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20029>> {
            return OrganizationDomainsApiFp(configuration).updateDomain(body, group, org, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationDomainsApi - object-oriented interface
 * @export
 * @class OrganizationDomainsApi
 * @extends {BaseAPI}
 */
export class OrganizationDomainsApi extends BaseAPI {
    /**
     * Domains allow you to further refine access within the context of an Organization. Domains are used as the primary association mechanism of Products to Users. In other words, if you wish a User to have access to a product, that user must be added to a Domain which already has that Product associated (the property is called associatedOrgProducts). Only those Products associated to the parent Organization are available to be associated to a child Domain. Every Organization automatically has an Administrative Domain created to allow access to the UEAuth product. It is not recommended that you add users to this Domain other than those who you wish to manage users, domains and roles.
     * @summary Create a Domain in a specified Organizations
     * @param {WriteDomain} body Create a new role
     * @param {string} group Auth Group Id or name
     * @param {string} org organization id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDomainsApi
     */
    public async createDomain(body: WriteDomain, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20029>> {
        return OrganizationDomainsApiFp(this.configuration).createDomain(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will hard delete your Domain. There are limits on delete when a domain has been associated to a user. You may need to remove users first.
     * @summary Delete a Domain
     * @param {string} group Auth Group Id or name
     * @param {string} org organization id guid
     * @param {string} id domain id guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDomainsApi
     */
    public async deleteDomain(group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20029>> {
        return OrganizationDomainsApiFp(this.configuration).deleteDomain(group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return a single Domain from within an Organization
     * @summary Get Domain by ID
     * @param {string} group Auth Group Id or name
     * @param {string} org organization id guid
     * @param {string} id domain id guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDomainsApi
     */
    public async getDomain(group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20029>> {
        return OrganizationDomainsApiFp(this.configuration).getDomain(group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all Domains within an Organization
     * @summary Get all Domains by Organizations Id
     * @param {string} group Auth Group Id or name
     * @param {string} org organization id
     * @param {string} [filter] oData filter Query
     * @param {string} [select] oData select Query
     * @param {string} [orderby] oData orderby Query
     * @param {number} [skip] oData skip Query
     * @param {number} [top] oData top Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDomainsApi
     */
    public async getDomains(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20030>> {
        return OrganizationDomainsApiFp(this.configuration).getDomains(group, org, filter, select, orderby, skip, top, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Domain's data
     * @summary Update a Domain
     * @param {Array<any>} body Create a new role
     * @param {string} group Auth Group Id or name
     * @param {string} org organization id guid
     * @param {string} id domain id guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDomainsApi
     */
    public async updateDomain(body: Array<any>, group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20029>> {
        return OrganizationDomainsApiFp(this.configuration).updateDomain(body, group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
}
