/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DefaultError } from '../models';
import { InlineResponse20021 } from '../models';
import { InlineResponse20022 } from '../models';
import { WriteNotification } from '../models';
/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Hard delete a notification. Notifications can not be updated once created, they can only be deleted. Keep in mind that if the notification was already processed, this will not change how that processing communicated the notification to the recipient.
         * @summary Hard delete a notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling deleteNotification.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNotification.');
            }
            const localVarPath = `/api/{group}/notification/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a specific notification. Keep in mind notification records only have a 30 day TTL
         * @summary Return a specific notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getNotification.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNotification.');
            }
            const localVarPath = `/api/{group}/notification/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all notifications in the group. Keep in mind notifications have a 30 day TTL
         * @summary Retrieve all notifications in the group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getNotifications.');
            }
            const localVarPath = `/api/{group}/notifications`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (filter !== undefined) {
                localVarQueryParameter['$filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['$select'] = select;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['$orderby'] = orderby;
            }

            if (skip !== undefined) {
                localVarQueryParameter['$skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['$top'] = top;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a stateless way to processes old notifications that may not be processed yet. You should build a cronjob to make this requet on a cadence of your choosing.
         * @summary Process up to 25 currently unprocessed notifications
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processBulkNotifications: async (group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling processBulkNotifications.');
            }
            const localVarPath = `/api/{group}/notification/process`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a specific notification that is currently not processed. If the notification is already processed, it will simply return that notification but take no action. Keep in mind notifications have a 30 day TTL
         * @summary Process a specific notification that is currently not processed.
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling processNotification.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling processNotification.');
            }
            const localVarPath = `/api/{group}/notification/{id}/process`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Define a new notification to be processed. Only possible if global & auth group notifications are enabled
         * @summary Define a new notification
         * @param {WriteNotification} body the notification as stored in ue auth system
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeNotification: async (body: WriteNotification, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling writeNotification.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling writeNotification.');
            }
            const localVarPath = `/api/{group}/notification`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Hard delete a notification. Notifications can not be updated once created, they can only be deleted. Keep in mind that if the notification was already processed, this will not change how that processing communicated the notification to the recipient.
         * @summary Hard delete a notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20022>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).deleteNotification(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a specific notification. Keep in mind notification records only have a 30 day TTL
         * @summary Return a specific notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20022>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).getNotification(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all notifications in the group. Keep in mind notifications have a 30 day TTL
         * @summary Retrieve all notifications in the group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20021>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).getNotifications(group, filter, select, orderby, skip, top, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This is a stateless way to processes old notifications that may not be processed yet. You should build a cronjob to make this requet on a cadence of your choosing.
         * @summary Process up to 25 currently unprocessed notifications
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processBulkNotifications(group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20021>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).processBulkNotifications(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Process a specific notification that is currently not processed. If the notification is already processed, it will simply return that notification but take no action. Keep in mind notifications have a 30 day TTL
         * @summary Process a specific notification that is currently not processed.
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20022>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).processNotification(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Define a new notification to be processed. Only possible if global & auth group notifications are enabled
         * @summary Define a new notification
         * @param {WriteNotification} body the notification as stored in ue auth system
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeNotification(body: WriteNotification, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20022>>> {
            const localVarAxiosArgs = await NotificationApiAxiosParamCreator(configuration).writeNotification(body, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Hard delete a notification. Notifications can not be updated once created, they can only be deleted. Keep in mind that if the notification was already processed, this will not change how that processing communicated the notification to the recipient.
         * @summary Hard delete a notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
            return NotificationApiFp(configuration).deleteNotification(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a specific notification. Keep in mind notification records only have a 30 day TTL
         * @summary Return a specific notification
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
            return NotificationApiFp(configuration).getNotification(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all notifications in the group. Keep in mind notifications have a 30 day TTL
         * @summary Retrieve all notifications in the group
         * @param {string} group the auth group ID associated to your business account
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20021>> {
            return NotificationApiFp(configuration).getNotifications(group, filter, select, orderby, skip, top, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a stateless way to processes old notifications that may not be processed yet. You should build a cronjob to make this requet on a cadence of your choosing.
         * @summary Process up to 25 currently unprocessed notifications
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processBulkNotifications(group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20021>> {
            return NotificationApiFp(configuration).processBulkNotifications(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a specific notification that is currently not processed. If the notification is already processed, it will simply return that notification but take no action. Keep in mind notifications have a 30 day TTL
         * @summary Process a specific notification that is currently not processed.
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id id of notification to process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processNotification(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
            return NotificationApiFp(configuration).processNotification(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Define a new notification to be processed. Only possible if global & auth group notifications are enabled
         * @summary Define a new notification
         * @param {WriteNotification} body the notification as stored in ue auth system
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeNotification(body: WriteNotification, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20022>> {
            return NotificationApiFp(configuration).writeNotification(body, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Hard delete a notification. Notifications can not be updated once created, they can only be deleted. Keep in mind that if the notification was already processed, this will not change how that processing communicated the notification to the recipient.
     * @summary Hard delete a notification
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of notification to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async deleteNotification(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20022>> {
        return NotificationApiFp(this.configuration).deleteNotification(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return a specific notification. Keep in mind notification records only have a 30 day TTL
     * @summary Return a specific notification
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of notification to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async getNotification(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20022>> {
        return NotificationApiFp(this.configuration).getNotification(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all notifications in the group. Keep in mind notifications have a 30 day TTL
     * @summary Retrieve all notifications in the group
     * @param {string} group the auth group ID associated to your business account
     * @param {string} [filter] oData filter Query
     * @param {string} [select] oData select Query
     * @param {string} [orderby] oData orderby Query
     * @param {string} [skip] oData skip Query
     * @param {string} [top] oData top Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async getNotifications(group: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20021>> {
        return NotificationApiFp(this.configuration).getNotifications(group, filter, select, orderby, skip, top, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a stateless way to processes old notifications that may not be processed yet. You should build a cronjob to make this requet on a cadence of your choosing.
     * @summary Process up to 25 currently unprocessed notifications
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async processBulkNotifications(group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20021>> {
        return NotificationApiFp(this.configuration).processBulkNotifications(group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Process a specific notification that is currently not processed. If the notification is already processed, it will simply return that notification but take no action. Keep in mind notifications have a 30 day TTL
     * @summary Process a specific notification that is currently not processed.
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id id of notification to process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async processNotification(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20022>> {
        return NotificationApiFp(this.configuration).processNotification(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Define a new notification to be processed. Only possible if global & auth group notifications are enabled
     * @summary Define a new notification
     * @param {WriteNotification} body the notification as stored in ue auth system
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public async writeNotification(body: WriteNotification, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20022>> {
        return NotificationApiFp(this.configuration).writeNotification(body, group, options).then((request) => request(this.axios, this.basePath));
    }
}
