/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccessTokens } from '../models';
import { ClientObject } from '../models';
import { ClientObjectUpdate } from '../models';
import { DefaultError } from '../models';
import { InitialAccessToken } from '../models';
import { InitialAccessTokenRequest } from '../models';
import { SimpleIAT } from '../models';
import { UserInfoObject } from '../models';
import { WriteClientObject } from '../models';
/**
 * OIDCApi - axios parameter creator
 * @export
 */
export const OIDCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request an OIDC initial access token (IAT). There are many uses for an IAT; however, one primary use in this API is to create new clients. Use this endpoint to request the IAT and then use that as your bearer token to create a new client. This only applies if open registration is disabled.
         * @summary Request an OIDC initial access token (IAT)
         * @param {string} group the auth group ID associated to your business account
         * @param {InitialAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitialAccessToken: async (group: string, body?: InitialAccessTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getInitialAccessToken.');
            }
            const localVarPath = `/{group}/token/initial-access`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token. This is primarily used for out of band authorizations for account settings.
         * @summary Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token
         * @param {string} group the auth group ID associated to your business account
         * @param {SimpleIAT} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimpleIAT: async (group: string, body?: SimpleIAT, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getSimpleIAT.');
            }
            const localVarPath = `/{group}/token/simple-iat`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * UserInfo endpoint will not work with a JWT token. It must be opaque.
         * @summary Standard OIDC UserInfo endpoint
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupMeGet: async (group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling groupMeGet.');
            }
            const localVarPath = `/{group}/me`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a registered client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Get a registerd lient - may require a registration access token
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRegIdGet: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling groupRegIdGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupRegIdGet.');
            }
            const localVarPath = `/{group}/reg/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a new client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Update a new client - may require a registration access token
         * @param {ClientObjectUpdate} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRegIdPut: async (body: ClientObjectUpdate, group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling groupRegIdPut.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling groupRegIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupRegIdPut.');
            }
            const localVarPath = `/{group}/reg/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new client - may require an initial access token depending on config
         * @summary Register a new client - may require an initial access token depending on config
         * @param {WriteClientObject} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRegPost: async (body: WriteClientObject, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling groupRegPost.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling groupRegPost.');
            }
            const localVarPath = `/{group}/reg`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a token code provided via code authorization flow
         * @summary Request a token code provided via code authorization flow
         * @param {string} grantType 
         * @param {string} clientSecret 
         * @param {string} redirectUri 
         * @param {string} code 
         * @param {string} clientId 
         * @param {string} scope 
         * @param {string} audience 
         * @param {string} codeVerifier 
         * @param {string} resource 
         * @param {string} clientAssertion 
         * @param {string} clientAssertionType 
         * @param {string} xOrganizationContext 
         * @param {string} xAccessFilterOrganization 
         * @param {string} xAccessFilterDomain 
         * @param {string} xAccessFilterProduct 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupTokenPostForm: async (grantType: string, clientSecret: string, redirectUri: string, code: string, clientId: string, scope: string, audience: string, codeVerifier: string, resource: string, clientAssertion: string, clientAssertionType: string, xOrganizationContext: string, xAccessFilterOrganization: string, xAccessFilterDomain: string, xAccessFilterProduct: string, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'clientSecret' is not null or undefined
            if (clientSecret === null || clientSecret === undefined) {
                throw new RequiredError('clientSecret','Required parameter clientSecret was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'audience' is not null or undefined
            if (audience === null || audience === undefined) {
                throw new RequiredError('audience','Required parameter audience was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'codeVerifier' is not null or undefined
            if (codeVerifier === null || codeVerifier === undefined) {
                throw new RequiredError('codeVerifier','Required parameter codeVerifier was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'resource' is not null or undefined
            if (resource === null || resource === undefined) {
                throw new RequiredError('resource','Required parameter resource was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'clientAssertion' is not null or undefined
            if (clientAssertion === null || clientAssertion === undefined) {
                throw new RequiredError('clientAssertion','Required parameter clientAssertion was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'clientAssertionType' is not null or undefined
            if (clientAssertionType === null || clientAssertionType === undefined) {
                throw new RequiredError('clientAssertionType','Required parameter clientAssertionType was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'xOrganizationContext' is not null or undefined
            if (xOrganizationContext === null || xOrganizationContext === undefined) {
                throw new RequiredError('xOrganizationContext','Required parameter xOrganizationContext was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'xAccessFilterOrganization' is not null or undefined
            if (xAccessFilterOrganization === null || xAccessFilterOrganization === undefined) {
                throw new RequiredError('xAccessFilterOrganization','Required parameter xAccessFilterOrganization was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'xAccessFilterDomain' is not null or undefined
            if (xAccessFilterDomain === null || xAccessFilterDomain === undefined) {
                throw new RequiredError('xAccessFilterDomain','Required parameter xAccessFilterDomain was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'xAccessFilterProduct' is not null or undefined
            if (xAccessFilterProduct === null || xAccessFilterProduct === undefined) {
                throw new RequiredError('xAccessFilterProduct','Required parameter xAccessFilterProduct was null or undefined when calling groupTokenPostForm.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling groupTokenPostForm.');
            }
            const localVarPath = `/{group}/token`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication bearer required

            // authentication openId required


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }

            if (redirectUri !== undefined) { 
                localVarFormParams.set('redirect_uri', redirectUri as any);
            }

            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }

            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }

            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }

            if (audience !== undefined) { 
                localVarFormParams.set('audience', audience as any);
            }

            if (codeVerifier !== undefined) { 
                localVarFormParams.set('code_verifier', codeVerifier as any);
            }

            if (resource !== undefined) { 
                localVarFormParams.set('resource', resource as any);
            }

            if (clientAssertion !== undefined) { 
                localVarFormParams.set('client_assertion', clientAssertion as any);
            }

            if (clientAssertionType !== undefined) { 
                localVarFormParams.set('client_assertion_type', clientAssertionType as any);
            }

            if (xOrganizationContext !== undefined) { 
                localVarFormParams.set('x_organization_context', xOrganizationContext as any);
            }

            if (xAccessFilterOrganization !== undefined) { 
                localVarFormParams.set('x_access_filter_organization', xAccessFilterOrganization as any);
            }

            if (xAccessFilterDomain !== undefined) { 
                localVarFormParams.set('x_access_filter_domain', xAccessFilterDomain as any);
            }

            if (xAccessFilterProduct !== undefined) { 
                localVarFormParams.set('x_access_filter_product', xAccessFilterProduct as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OIDCApi - functional programming interface
 * @export
 */
export const OIDCApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Request an OIDC initial access token (IAT). There are many uses for an IAT; however, one primary use in this API is to create new clients. Use this endpoint to request the IAT and then use that as your bearer token to create a new client. This only applies if open registration is disabled.
         * @summary Request an OIDC initial access token (IAT)
         * @param {string} group the auth group ID associated to your business account
         * @param {InitialAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInitialAccessToken(group: string, body?: InitialAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InitialAccessToken>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).getInitialAccessToken(group, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token. This is primarily used for out of band authorizations for account settings.
         * @summary Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token
         * @param {string} group the auth group ID associated to your business account
         * @param {SimpleIAT} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimpleIAT(group: string, body?: SimpleIAT, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InitialAccessToken>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).getSimpleIAT(group, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * UserInfo endpoint will not work with a JWT token. It must be opaque.
         * @summary Standard OIDC UserInfo endpoint
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupMeGet(group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserInfoObject>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).groupMeGet(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a registered client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Get a registerd lient - may require a registration access token
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegIdGet(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ClientObject>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).groupRegIdGet(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a new client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Update a new client - may require a registration access token
         * @param {ClientObjectUpdate} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegIdPut(body: ClientObjectUpdate, group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ClientObject>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).groupRegIdPut(body, group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Register a new client - may require an initial access token depending on config
         * @summary Register a new client - may require an initial access token depending on config
         * @param {WriteClientObject} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegPost(body: WriteClientObject, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ClientObject>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).groupRegPost(body, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request a token code provided via code authorization flow
         * @summary Request a token code provided via code authorization flow
         * @param {string} grantType 
         * @param {string} clientSecret 
         * @param {string} redirectUri 
         * @param {string} code 
         * @param {string} clientId 
         * @param {string} scope 
         * @param {string} audience 
         * @param {string} codeVerifier 
         * @param {string} resource 
         * @param {string} clientAssertion 
         * @param {string} clientAssertionType 
         * @param {string} xOrganizationContext 
         * @param {string} xAccessFilterOrganization 
         * @param {string} xAccessFilterDomain 
         * @param {string} xAccessFilterProduct 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupTokenPostForm(grantType: string, clientSecret: string, redirectUri: string, code: string, clientId: string, scope: string, audience: string, codeVerifier: string, resource: string, clientAssertion: string, clientAssertionType: string, xOrganizationContext: string, xAccessFilterOrganization: string, xAccessFilterDomain: string, xAccessFilterProduct: string, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<AccessTokens>>> {
            const localVarAxiosArgs = await OIDCApiAxiosParamCreator(configuration).groupTokenPostForm(grantType, clientSecret, redirectUri, code, clientId, scope, audience, codeVerifier, resource, clientAssertion, clientAssertionType, xOrganizationContext, xAccessFilterOrganization, xAccessFilterDomain, xAccessFilterProduct, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OIDCApi - factory interface
 * @export
 */
export const OIDCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Request an OIDC initial access token (IAT). There are many uses for an IAT; however, one primary use in this API is to create new clients. Use this endpoint to request the IAT and then use that as your bearer token to create a new client. This only applies if open registration is disabled.
         * @summary Request an OIDC initial access token (IAT)
         * @param {string} group the auth group ID associated to your business account
         * @param {InitialAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInitialAccessToken(group: string, body?: InitialAccessTokenRequest, options?: AxiosRequestConfig): Promise<AxiosResponse<InitialAccessToken>> {
            return OIDCApiFp(configuration).getInitialAccessToken(group, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token. This is primarily used for out of band authorizations for account settings.
         * @summary Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token
         * @param {string} group the auth group ID associated to your business account
         * @param {SimpleIAT} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimpleIAT(group: string, body?: SimpleIAT, options?: AxiosRequestConfig): Promise<AxiosResponse<InitialAccessToken>> {
            return OIDCApiFp(configuration).getSimpleIAT(group, body, options).then((request) => request(axios, basePath));
        },
        /**
         * UserInfo endpoint will not work with a JWT token. It must be opaque.
         * @summary Standard OIDC UserInfo endpoint
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupMeGet(group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<UserInfoObject>> {
            return OIDCApiFp(configuration).groupMeGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a registered client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Get a registerd lient - may require a registration access token
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegIdGet(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ClientObject>> {
            return OIDCApiFp(configuration).groupRegIdGet(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a new client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
         * @summary Update a new client - may require a registration access token
         * @param {ClientObjectUpdate} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {string} id the client id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegIdPut(body: ClientObjectUpdate, group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ClientObject>> {
            return OIDCApiFp(configuration).groupRegIdPut(body, group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new client - may require an initial access token depending on config
         * @summary Register a new client - may require an initial access token depending on config
         * @param {WriteClientObject} body 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRegPost(body: WriteClientObject, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ClientObject>> {
            return OIDCApiFp(configuration).groupRegPost(body, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a token code provided via code authorization flow
         * @summary Request a token code provided via code authorization flow
         * @param {string} grantType 
         * @param {string} clientSecret 
         * @param {string} redirectUri 
         * @param {string} code 
         * @param {string} clientId 
         * @param {string} scope 
         * @param {string} audience 
         * @param {string} codeVerifier 
         * @param {string} resource 
         * @param {string} clientAssertion 
         * @param {string} clientAssertionType 
         * @param {string} xOrganizationContext 
         * @param {string} xAccessFilterOrganization 
         * @param {string} xAccessFilterDomain 
         * @param {string} xAccessFilterProduct 
         * @param {string} group the auth group ID associated to your business account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupTokenPostForm(grantType: string, clientSecret: string, redirectUri: string, code: string, clientId: string, scope: string, audience: string, codeVerifier: string, resource: string, clientAssertion: string, clientAssertionType: string, xOrganizationContext: string, xAccessFilterOrganization: string, xAccessFilterDomain: string, xAccessFilterProduct: string, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<AccessTokens>> {
            return OIDCApiFp(configuration).groupTokenPostForm(grantType, clientSecret, redirectUri, code, clientId, scope, audience, codeVerifier, resource, clientAssertion, clientAssertionType, xOrganizationContext, xAccessFilterOrganization, xAccessFilterDomain, xAccessFilterProduct, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OIDCApi - object-oriented interface
 * @export
 * @class OIDCApi
 * @extends {BaseAPI}
 */
export class OIDCApi extends BaseAPI {
    /**
     * Request an OIDC initial access token (IAT). There are many uses for an IAT; however, one primary use in this API is to create new clients. Use this endpoint to request the IAT and then use that as your bearer token to create a new client. This only applies if open registration is disabled.
     * @summary Request an OIDC initial access token (IAT)
     * @param {string} group the auth group ID associated to your business account
     * @param {InitialAccessTokenRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async getInitialAccessToken(group: string, body?: InitialAccessTokenRequest, options?: AxiosRequestConfig) : Promise<AxiosResponse<InitialAccessToken>> {
        return OIDCApiFp(this.configuration).getInitialAccessToken(group, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token. This is primarily used for out of band authorizations for account settings.
     * @summary Request an initial access token (IAT) tied to your account and a state using basic auth or bearer token
     * @param {string} group the auth group ID associated to your business account
     * @param {SimpleIAT} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async getSimpleIAT(group: string, body?: SimpleIAT, options?: AxiosRequestConfig) : Promise<AxiosResponse<InitialAccessToken>> {
        return OIDCApiFp(this.configuration).getSimpleIAT(group, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * UserInfo endpoint will not work with a JWT token. It must be opaque.
     * @summary Standard OIDC UserInfo endpoint
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async groupMeGet(group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserInfoObject>> {
        return OIDCApiFp(this.configuration).groupMeGet(group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a registered client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
     * @summary Get a registerd lient - may require a registration access token
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id the client id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async groupRegIdGet(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ClientObject>> {
        return OIDCApiFp(this.configuration).groupRegIdGet(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a new client - may require a registration access (RAI) token. If the RAI is required (configuration) it will rotate on each update and you will need to keep track of it. If you have lost your token, you can request a new one from the operations/client endpoint.
     * @summary Update a new client - may require a registration access token
     * @param {ClientObjectUpdate} body 
     * @param {string} group the auth group ID associated to your business account
     * @param {string} id the client id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async groupRegIdPut(body: ClientObjectUpdate, group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ClientObject>> {
        return OIDCApiFp(this.configuration).groupRegIdPut(body, group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register a new client - may require an initial access token depending on config
     * @summary Register a new client - may require an initial access token depending on config
     * @param {WriteClientObject} body 
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async groupRegPost(body: WriteClientObject, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ClientObject>> {
        return OIDCApiFp(this.configuration).groupRegPost(body, group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request a token code provided via code authorization flow
     * @summary Request a token code provided via code authorization flow
     * @param {string} grantType 
     * @param {string} clientSecret 
     * @param {string} redirectUri 
     * @param {string} code 
     * @param {string} clientId 
     * @param {string} scope 
     * @param {string} audience 
     * @param {string} codeVerifier 
     * @param {string} resource 
     * @param {string} clientAssertion 
     * @param {string} clientAssertionType 
     * @param {string} xOrganizationContext 
     * @param {string} xAccessFilterOrganization 
     * @param {string} xAccessFilterDomain 
     * @param {string} xAccessFilterProduct 
     * @param {string} group the auth group ID associated to your business account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OIDCApi
     */
    public async groupTokenPostForm(grantType: string, clientSecret: string, redirectUri: string, code: string, clientId: string, scope: string, audience: string, codeVerifier: string, resource: string, clientAssertion: string, clientAssertionType: string, xOrganizationContext: string, xAccessFilterOrganization: string, xAccessFilterDomain: string, xAccessFilterProduct: string, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<AccessTokens>> {
        return OIDCApiFp(this.configuration).groupTokenPostForm(grantType, clientSecret, redirectUri, code, clientId, scope, audience, codeVerifier, resource, clientAssertion, clientAssertionType, xOrganizationContext, xAccessFilterOrganization, xAccessFilterDomain, xAccessFilterProduct, group, options).then((request) => request(this.axios, this.basePath));
    }
}
