/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DefaultError } from '../models';
import { InlineResponse20023 } from '../models';
import { InlineResponse20024 } from '../models';
import { InlineResponse20025 } from '../models';
import { WriteProduct } from '../models';
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find out how many permissions reference this product. Useful to run before a delete operation.
         * @summary Find out how many permissions reference this product
         * @param {string} group Auth Group Id or name
         * @param {string} product Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermissionsForProduct: async (group: string, product: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling checkPermissionsForProduct.');
            }
            // verify required parameter 'product' is not null or undefined
            if (product === null || product === undefined) {
                throw new RequiredError('product','Required parameter product was null or undefined when calling checkPermissionsForProduct.');
            }
            const localVarPath = `/api/{group}/products/{product}/reference-check/permissions`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * In this API, the concept of a Product is a business level entity that represents software your company creates or otherwise manages to which access must be provided to Accounts, Organizations, and Domains. Products are not the same thing as an OIDC Client, but you may wish to have a one to many relationship between Products and OIDC Clients, something which can be managed on the Product object with the asssociatedClients array. This system does not enforce access to a Product in any way, we are simply recording and categorizing the relationship of the Product to the AuthGroup, Organizatin, Domains and ultimately Accounts (Users). It is the responsibility of the Product software itself (that is to say, not the responsibility of UE Auth or United Effects) to appropriately request tokens, scopes, and other information from this system (UE Auth) to then determine and enforce access.
         * @summary Define a Products in your AuthGroup
         * @param {WriteProduct} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (body: WriteProduct, group: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProduct.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createProduct.');
            }
            const localVarPath = `/api/{group}/products`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will completely delete a product. There are limits to deleting a Product if it associated to Organizations and Domains. You may need to dissassociate them first as those associations potentially represent internal (internal to your company) licenses or agreements. Once cleared of assocations, deleting a product will delete all associated permissions.
         * @summary Delete a Product
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling deleteProduct.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProduct.');
            }
            const localVarPath = `/api/{group}/products/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Query a single Product by ID
         * @summary Get a Product's Info
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getProduct.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProduct.');
            }
            const localVarPath = `/api/{group}/products/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all Products defined as part of your AuthGroup
         * @summary Get all Products
         * @param {string} group Auth Group Id or name
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (group: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getProducts.');
            }
            const localVarPath = `/api/{group}/products`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (filter !== undefined) {
                localVarQueryParameter['$filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['$select'] = select;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['$orderby'] = orderby;
            }

            if (skip !== undefined) {
                localVarQueryParameter['$skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['$top'] = top;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Change information about your Product
         * @summary Update a Product's information
         * @param {Array<any>} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (body: Array<any>, group: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProduct.');
            }
            const localVarPath = `/api/{group}/products/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find out how many permissions reference this product. Useful to run before a delete operation.
         * @summary Find out how many permissions reference this product
         * @param {string} group Auth Group Id or name
         * @param {string} product Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPermissionsForProduct(group: string, product: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20025>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).checkPermissionsForProduct(group, product, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * In this API, the concept of a Product is a business level entity that represents software your company creates or otherwise manages to which access must be provided to Accounts, Organizations, and Domains. Products are not the same thing as an OIDC Client, but you may wish to have a one to many relationship between Products and OIDC Clients, something which can be managed on the Product object with the asssociatedClients array. This system does not enforce access to a Product in any way, we are simply recording and categorizing the relationship of the Product to the AuthGroup, Organizatin, Domains and ultimately Accounts (Users). It is the responsibility of the Product software itself (that is to say, not the responsibility of UE Auth or United Effects) to appropriately request tokens, scopes, and other information from this system (UE Auth) to then determine and enforce access.
         * @summary Define a Products in your AuthGroup
         * @param {WriteProduct} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(body: WriteProduct, group: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20023>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).createProduct(body, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will completely delete a product. There are limits to deleting a Product if it associated to Organizations and Domains. You may need to dissassociate them first as those associations potentially represent internal (internal to your company) licenses or agreements. Once cleared of assocations, deleting a product will delete all associated permissions.
         * @summary Delete a Product
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20024>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProduct(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Query a single Product by ID
         * @summary Get a Product's Info
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20024>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProduct(group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return all Products defined as part of your AuthGroup
         * @summary Get all Products
         * @param {string} group Auth Group Id or name
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(group: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20023>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProducts(group, filter, select, orderby, skip, top, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Change information about your Product
         * @summary Update a Product's information
         * @param {Array<any>} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20024>>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).updateProduct(body, group, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find out how many permissions reference this product. Useful to run before a delete operation.
         * @summary Find out how many permissions reference this product
         * @param {string} group Auth Group Id or name
         * @param {string} product Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPermissionsForProduct(group: string, product: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20025>> {
            return ProductsApiFp(configuration).checkPermissionsForProduct(group, product, options).then((request) => request(axios, basePath));
        },
        /**
         * In this API, the concept of a Product is a business level entity that represents software your company creates or otherwise manages to which access must be provided to Accounts, Organizations, and Domains. Products are not the same thing as an OIDC Client, but you may wish to have a one to many relationship between Products and OIDC Clients, something which can be managed on the Product object with the asssociatedClients array. This system does not enforce access to a Product in any way, we are simply recording and categorizing the relationship of the Product to the AuthGroup, Organizatin, Domains and ultimately Accounts (Users). It is the responsibility of the Product software itself (that is to say, not the responsibility of UE Auth or United Effects) to appropriately request tokens, scopes, and other information from this system (UE Auth) to then determine and enforce access.
         * @summary Define a Products in your AuthGroup
         * @param {WriteProduct} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(body: WriteProduct, group: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20023>> {
            return ProductsApiFp(configuration).createProduct(body, group, options).then((request) => request(axios, basePath));
        },
        /**
         * This will completely delete a product. There are limits to deleting a Product if it associated to Organizations and Domains. You may need to dissassociate them first as those associations potentially represent internal (internal to your company) licenses or agreements. Once cleared of assocations, deleting a product will delete all associated permissions.
         * @summary Delete a Product
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20024>> {
            return ProductsApiFp(configuration).deleteProduct(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Query a single Product by ID
         * @summary Get a Product's Info
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20024>> {
            return ProductsApiFp(configuration).getProduct(group, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all Products defined as part of your AuthGroup
         * @summary Get all Products
         * @param {string} group Auth Group Id or name
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {number} [skip] oData skip Query
         * @param {number} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(group: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20023>> {
            return ProductsApiFp(configuration).getProducts(group, filter, select, orderby, skip, top, options).then((request) => request(axios, basePath));
        },
        /**
         * Change information about your Product
         * @summary Update a Product's information
         * @param {Array<any>} body Updated user object
         * @param {string} group Auth Group Id or name
         * @param {string} id Unique user identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20024>> {
            return ProductsApiFp(configuration).updateProduct(body, group, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Find out how many permissions reference this product. Useful to run before a delete operation.
     * @summary Find out how many permissions reference this product
     * @param {string} group Auth Group Id or name
     * @param {string} product Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async checkPermissionsForProduct(group: string, product: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20025>> {
        return ProductsApiFp(this.configuration).checkPermissionsForProduct(group, product, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * In this API, the concept of a Product is a business level entity that represents software your company creates or otherwise manages to which access must be provided to Accounts, Organizations, and Domains. Products are not the same thing as an OIDC Client, but you may wish to have a one to many relationship between Products and OIDC Clients, something which can be managed on the Product object with the asssociatedClients array. This system does not enforce access to a Product in any way, we are simply recording and categorizing the relationship of the Product to the AuthGroup, Organizatin, Domains and ultimately Accounts (Users). It is the responsibility of the Product software itself (that is to say, not the responsibility of UE Auth or United Effects) to appropriately request tokens, scopes, and other information from this system (UE Auth) to then determine and enforce access.
     * @summary Define a Products in your AuthGroup
     * @param {WriteProduct} body Updated user object
     * @param {string} group Auth Group Id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async createProduct(body: WriteProduct, group: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20023>> {
        return ProductsApiFp(this.configuration).createProduct(body, group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will completely delete a product. There are limits to deleting a Product if it associated to Organizations and Domains. You may need to dissassociate them first as those associations potentially represent internal (internal to your company) licenses or agreements. Once cleared of assocations, deleting a product will delete all associated permissions.
     * @summary Delete a Product
     * @param {string} group Auth Group Id or name
     * @param {string} id Unique user identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async deleteProduct(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20024>> {
        return ProductsApiFp(this.configuration).deleteProduct(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query a single Product by ID
     * @summary Get a Product's Info
     * @param {string} group Auth Group Id or name
     * @param {string} id Unique user identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async getProduct(group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20024>> {
        return ProductsApiFp(this.configuration).getProduct(group, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return all Products defined as part of your AuthGroup
     * @summary Get all Products
     * @param {string} group Auth Group Id or name
     * @param {string} [filter] oData filter Query
     * @param {string} [select] oData select Query
     * @param {string} [orderby] oData orderby Query
     * @param {number} [skip] oData skip Query
     * @param {number} [top] oData top Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async getProducts(group: string, filter?: string, select?: string, orderby?: string, skip?: number, top?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20023>> {
        return ProductsApiFp(this.configuration).getProducts(group, filter, select, orderby, skip, top, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Change information about your Product
     * @summary Update a Product's information
     * @param {Array<any>} body Updated user object
     * @param {string} group Auth Group Id or name
     * @param {string} id Unique user identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public async updateProduct(body: Array<any>, group: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20024>> {
        return ProductsApiFp(this.configuration).updateProduct(body, group, id, options).then((request) => request(this.axios, this.basePath));
    }
}
