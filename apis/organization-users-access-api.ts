/* tslint:disable */
/* eslint-disable */
/**
 * ue-auth
 * UEAuth is provided by <a href='https://unitedeffects.com'>United Effects LLC</a>. Copyright &#169; 2023, all rights reserved.<br><br> As a general reference, this provider implements the following OIDC endpoints. All OpenID Connect schema specific endpoints follow the pattern <code>/{group}/path</code>.<br>UE Auth identity and access endpoints follow the pattern <code>/api/{group}/path</code>. Full documentation on the OpenID Connect specification can be found here: <a href='https://openid.net/developers/specs/'>OIDC API DOCUMENTATION</a>.<br><code><br>authorization: '/{group}/auth',<br> check_session: '/{group}/session/check',<br> code_verification: '/{group}/device',<br> device_authorization: '/{group}/device/auth',<br> end_session: '/{group}/session/end',<br> introspection: '/{group}/token/introspection',<br> initial_access: '/{group}/token/initial_access',<br> jwks: '/{group}/jwks',<br> pushed_authorization_request: '/{group}/request',<br> registration: '/{group}/reg',<br> revocation: '/{group}/token/revocation',<br> token: '/{group}/token',<br> userinfo: '/{group}/me'</code><br><br> <small>Not all of the above endpoints are detailed with contracts in this API documentation. Please reference the <a href='https://openid.net/developers/specs/'>OIDC</a> docs for any path specs not shown.</small><br><br> <h2>Query and Patch Standards</h2>This API uses <a href='https://www.odata.org/documentation/'>oData</a> and <a href='http://jsonpatch.com/'>JSON Patch</a> as standards for most paginated GET and PATCH methods. You may wish to review these standards.
 *
 * OpenAPI spec version: 1.32.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DefaultError } from '../models';
import { GetAccount } from '../models';
import { GetAccounts } from '../models';
import { InlineResponse20012 } from '../models';
import { InlineResponse2004 } from '../models';
import { InlineResponse201 } from '../models';
import { InlineResponse2014 } from '../models';
import { OrgAccountsBody } from '../models';
import { OrgAccountsBody1 } from '../models';
import { UpdateUserAccess } from '../models';
import { UserAccessAction } from '../models';
import { WriteAccess } from '../models';
import { WriteAccountByOrg } from '../models';
/**
 * OrganizationUsersAccessApi - axios parameter creator
 * @export
 */
export const OrganizationUsersAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will bulk remove accounts from an organization. This API requires a body to be passed with a DELETE method.
         * @summary Remove multiple accounts from an organization.
         * @param {Array<string>} body Array of Account Ids to be removed
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRemoveAccountsFromOrg: async (body: Array<string>, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bulkRemoveAccountsFromOrg.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling bulkRemoveAccountsFromOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bulkRemoveAccountsFromOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will register multiple accounts to the organization. This API takes account Ids not email addresses. Unlike individual additions to an organization, this bulk endpoint will not create the accounts in the AuthGroup if they do not exist.
         * @summary Register multiple existing Auth Group accounts to the organization.
         * @param {Array<string>} body Array of Account Ids to be added
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkWriteAccountsToOrg: async (body: Array<string>, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bulkWriteAccountsToOrg.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling bulkWriteAccountsToOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling bulkWriteAccountsToOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add multiple user accounts to multiple domains and roles. This is only an addition API and will not remove any roles or domains.
         * @summary Add multiple user accounts to multiple domains and roles
         * @param {OrgAccountsBody} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineBulkUserAccessAdd: async (body: OrgAccountsBody, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defineBulkUserAccessAdd.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling defineBulkUserAccessAdd.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling defineBulkUserAccessAdd.');
            }
            const localVarPath = `/api/{group}/access/organization/{org}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove multiple user accounts from multiple domains and roles. This is only a remove API and will not add any roles or domains.
         * @summary Remove multiple user accounts from multiple domains and roles
         * @param {OrgAccountsBody1} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineBulkUserAccessRemove: async (body: OrgAccountsBody1, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defineBulkUserAccessRemove.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling defineBulkUserAccessRemove.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling defineBulkUserAccessRemove.');
            }
            const localVarPath = `/api/{group}/access/organization/{org}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to change the domains and roles associated to an Account within the context of an Organization. Remember that this will overwrite the record not patch it.
         * @summary Overwrite defined user access of an Account in the context of a single Organization
         * @param {WriteAccess} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {string} [notify] if notifications are enabled, you can override and skip them by setting this to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineUserAccess: async (body: WriteAccess, group: string, org: string, id: string, notify?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling defineUserAccess.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling defineUserAccess.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling defineUserAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling defineUserAccess.');
            }
            const localVarPath = `/api/{group}/access/organization/{org}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (notify !== undefined) {
                localVarQueryParameter['notify'] = notify;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Identify a single user associated to an organization. Remember that Account records only return create/modified/active metadata, an email and an id.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrg: async (group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getAccountByOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getAccountByOrg.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAccountByOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This API allows you to browse the email and id of every user that has been added to your organization.
         * @summary Retrieve all users associated to an organization
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsByOrg: async (group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getAccountsByOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getAccountsByOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/accounts`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (filter !== undefined) {
                localVarQueryParameter['$filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['$select'] = select;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['$orderby'] = orderby;
            }

            if (skip !== undefined) {
                localVarQueryParameter['$skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['$top'] = top;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specific record of domains and roles within the context of an organization. You can update and send back this record as part of the associated PUT endpoint to make changes.
         * @summary Get defined user access in order to make edits with PUT
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedUserAccess: async (group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getDefinedUserAccess.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling getDefinedUserAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDefinedUserAccess.');
            }
            const localVarPath = `/api/{group}/access/organization/{org}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint removes a user form an organization and cuts off all access immediately. Please be advised, if a user obtained access records as part ofa  JWT token, that token may still show access until it expires.
         * @summary Remove an organization from user's access
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgFromAccess: async (group: string, org: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling removeOrgFromAccess.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling removeOrgFromAccess.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeOrgFromAccess.');
            }
            const localVarPath = `/api/{group}/access/organization/{org}/account/{id}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup with an org context
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization context
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccountsFromOrg: async (group: string, org: string, q: string, restrictEmail?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling searchAccountsFromOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling searchAccountsFromOrg.');
            }
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchAccountsFromOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/accounts/search`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (restrictEmail !== undefined) {
                localVarQueryParameter['restrictEmail'] = restrictEmail;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If you intend to add or create a user specific to your organization, this is the correct API. You may want to use the account/search API first. This method will check to see if a user with the email specified exists. If the user exists, an organization access record will be added to that user's account, otherwise, the user is first created and then the access record added. This API does not allow you to set a password, one will be generated. If notifications are enabled (recommended), the caller will never see the password and a notification will be sent to the user or they can simply trigger a password reset to claim the account. If notifications are not enabled, the generated password will be returned with this call and include a warning that notifications are disabled. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner.
         * @summary Register a new or existing user as part of an organization
         * @param {WriteAccountByOrg} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeAccountToOrg: async (body: WriteAccountByOrg, group: string, org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling writeAccountToOrg.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling writeAccountToOrg.');
            }
            // verify required parameter 'org' is not null or undefined
            if (org === null || org === undefined) {
                throw new RequiredError('org','Required parameter org was null or undefined when calling writeAccountToOrg.');
            }
            const localVarPath = `/api/{group}/organization/{org}/account`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            // authentication openId required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationUsersAccessApi - functional programming interface
 * @export
 */
export const OrganizationUsersAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will bulk remove accounts from an organization. This API requires a body to be passed with a DELETE method.
         * @summary Remove multiple accounts from an organization.
         * @param {Array<string>} body Array of Account Ids to be removed
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRemoveAccountsFromOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2014>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).bulkRemoveAccountsFromOrg(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will register multiple accounts to the organization. This API takes account Ids not email addresses. Unlike individual additions to an organization, this bulk endpoint will not create the accounts in the AuthGroup if they do not exist.
         * @summary Register multiple existing Auth Group accounts to the organization.
         * @param {Array<string>} body Array of Account Ids to be added
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkWriteAccountsToOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2014>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).bulkWriteAccountsToOrg(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add multiple user accounts to multiple domains and roles. This is only an addition API and will not remove any roles or domains.
         * @summary Add multiple user accounts to multiple domains and roles
         * @param {OrgAccountsBody} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineBulkUserAccessAdd(body: OrgAccountsBody, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20012>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).defineBulkUserAccessAdd(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove multiple user accounts from multiple domains and roles. This is only a remove API and will not add any roles or domains.
         * @summary Remove multiple user accounts from multiple domains and roles
         * @param {OrgAccountsBody1} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineBulkUserAccessRemove(body: OrgAccountsBody1, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20012>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).defineBulkUserAccessRemove(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows you to change the domains and roles associated to an Account within the context of an Organization. Remember that this will overwrite the record not patch it.
         * @summary Overwrite defined user access of an Account in the context of a single Organization
         * @param {WriteAccess} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {string} [notify] if notifications are enabled, you can override and skip them by setting this to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineUserAccess(body: WriteAccess, group: string, org: string, id: string, notify?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UpdateUserAccess>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).defineUserAccess(body, group, org, id, notify, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Identify a single user associated to an organization. Remember that Account records only return create/modified/active metadata, an email and an id.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByOrg(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccount>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).getAccountByOrg(group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This API allows you to browse the email and id of every user that has been added to your organization.
         * @summary Retrieve all users associated to an organization
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsByOrg(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAccounts>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).getAccountsByOrg(group, org, filter, select, orderby, skip, top, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the specific record of domains and roles within the context of an organization. You can update and send back this record as part of the associated PUT endpoint to make changes.
         * @summary Get defined user access in order to make edits with PUT
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedUserAccess(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WriteAccess>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).getDefinedUserAccess(group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint removes a user form an organization and cuts off all access immediately. Please be advised, if a user obtained access records as part ofa  JWT token, that token may still show access until it expires.
         * @summary Remove an organization from user's access
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrgFromAccess(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserAccessAction>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).removeOrgFromAccess(group, org, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup with an org context
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization context
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccountsFromOrg(group: string, org: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2004>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).searchAccountsFromOrg(group, org, q, restrictEmail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If you intend to add or create a user specific to your organization, this is the correct API. You may want to use the account/search API first. This method will check to see if a user with the email specified exists. If the user exists, an organization access record will be added to that user's account, otherwise, the user is first created and then the access record added. This API does not allow you to set a password, one will be generated. If notifications are enabled (recommended), the caller will never see the password and a notification will be sent to the user or they can simply trigger a password reset to claim the account. If notifications are not enabled, the generated password will be returned with this call and include a warning that notifications are disabled. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner.
         * @summary Register a new or existing user as part of an organization
         * @param {WriteAccountByOrg} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeAccountToOrg(body: WriteAccountByOrg, group: string, org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse201>>> {
            const localVarAxiosArgs = await OrganizationUsersAccessApiAxiosParamCreator(configuration).writeAccountToOrg(body, group, org, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationUsersAccessApi - factory interface
 * @export
 */
export const OrganizationUsersAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will bulk remove accounts from an organization. This API requires a body to be passed with a DELETE method.
         * @summary Remove multiple accounts from an organization.
         * @param {Array<string>} body Array of Account Ids to be removed
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRemoveAccountsFromOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2014>> {
            return OrganizationUsersAccessApiFp(configuration).bulkRemoveAccountsFromOrg(body, group, org, options).then((request) => request(axios, basePath));
        },
        /**
         * This will register multiple accounts to the organization. This API takes account Ids not email addresses. Unlike individual additions to an organization, this bulk endpoint will not create the accounts in the AuthGroup if they do not exist.
         * @summary Register multiple existing Auth Group accounts to the organization.
         * @param {Array<string>} body Array of Account Ids to be added
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkWriteAccountsToOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2014>> {
            return OrganizationUsersAccessApiFp(configuration).bulkWriteAccountsToOrg(body, group, org, options).then((request) => request(axios, basePath));
        },
        /**
         * Add multiple user accounts to multiple domains and roles. This is only an addition API and will not remove any roles or domains.
         * @summary Add multiple user accounts to multiple domains and roles
         * @param {OrgAccountsBody} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineBulkUserAccessAdd(body: OrgAccountsBody, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20012>> {
            return OrganizationUsersAccessApiFp(configuration).defineBulkUserAccessAdd(body, group, org, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove multiple user accounts from multiple domains and roles. This is only a remove API and will not add any roles or domains.
         * @summary Remove multiple user accounts from multiple domains and roles
         * @param {OrgAccountsBody1} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineBulkUserAccessRemove(body: OrgAccountsBody1, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20012>> {
            return OrganizationUsersAccessApiFp(configuration).defineBulkUserAccessRemove(body, group, org, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to change the domains and roles associated to an Account within the context of an Organization. Remember that this will overwrite the record not patch it.
         * @summary Overwrite defined user access of an Account in the context of a single Organization
         * @param {WriteAccess} body Updated access object
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {string} [notify] if notifications are enabled, you can override and skip them by setting this to false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineUserAccess(body: WriteAccess, group: string, org: string, id: string, notify?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<UpdateUserAccess>> {
            return OrganizationUsersAccessApiFp(configuration).defineUserAccess(body, group, org, id, notify, options).then((request) => request(axios, basePath));
        },
        /**
         * Identify a single user associated to an organization. Remember that Account records only return create/modified/active metadata, an email and an id.
         * @summary Find a User with ID
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} id id of account type to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByOrg(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccount>> {
            return OrganizationUsersAccessApiFp(configuration).getAccountByOrg(group, org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API allows you to browse the email and id of every user that has been added to your organization.
         * @summary Retrieve all users associated to an organization
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {string} [filter] oData filter Query
         * @param {string} [select] oData select Query
         * @param {string} [orderby] oData orderby Query
         * @param {string} [skip] oData skip Query
         * @param {string} [top] oData top Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsByOrg(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAccounts>> {
            return OrganizationUsersAccessApiFp(configuration).getAccountsByOrg(group, org, filter, select, orderby, skip, top, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the specific record of domains and roles within the context of an organization. You can update and send back this record as part of the associated PUT endpoint to make changes.
         * @summary Get defined user access in order to make edits with PUT
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedUserAccess(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<WriteAccess>> {
            return OrganizationUsersAccessApiFp(configuration).getDefinedUserAccess(group, org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint removes a user form an organization and cuts off all access immediately. Please be advised, if a user obtained access records as part ofa  JWT token, that token may still show access until it expires.
         * @summary Remove an organization from user's access
         * @param {string} group Auth Group Id or name
         * @param {string} org Organization id access is being applied to
         * @param {string} id id that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrgFromAccess(group: string, org: string, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<UserAccessAction>> {
            return OrganizationUsersAccessApiFp(configuration).removeOrgFromAccess(group, org, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to search accounts in the authgroup using a text search
         * @summary Search Accounts in the authGroup with an org context
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization context
         * @param {string} q keyword search
         * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccountsFromOrg(group: string, org: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2004>> {
            return OrganizationUsersAccessApiFp(configuration).searchAccountsFromOrg(group, org, q, restrictEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * If you intend to add or create a user specific to your organization, this is the correct API. You may want to use the account/search API first. This method will check to see if a user with the email specified exists. If the user exists, an organization access record will be added to that user's account, otherwise, the user is first created and then the access record added. This API does not allow you to set a password, one will be generated. If notifications are enabled (recommended), the caller will never see the password and a notification will be sent to the user or they can simply trigger a password reset to claim the account. If notifications are not enabled, the generated password will be returned with this call and include a warning that notifications are disabled. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner.
         * @summary Register a new or existing user as part of an organization
         * @param {WriteAccountByOrg} body Account data to be written
         * @param {string} group the auth group ID associated to your business account
         * @param {string} org the organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeAccountToOrg(body: WriteAccountByOrg, group: string, org: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse201>> {
            return OrganizationUsersAccessApiFp(configuration).writeAccountToOrg(body, group, org, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationUsersAccessApi - object-oriented interface
 * @export
 * @class OrganizationUsersAccessApi
 * @extends {BaseAPI}
 */
export class OrganizationUsersAccessApi extends BaseAPI {
    /**
     * This will bulk remove accounts from an organization. This API requires a body to be passed with a DELETE method.
     * @summary Remove multiple accounts from an organization.
     * @param {Array<string>} body Array of Account Ids to be removed
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async bulkRemoveAccountsFromOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2014>> {
        return OrganizationUsersAccessApiFp(this.configuration).bulkRemoveAccountsFromOrg(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will register multiple accounts to the organization. This API takes account Ids not email addresses. Unlike individual additions to an organization, this bulk endpoint will not create the accounts in the AuthGroup if they do not exist.
     * @summary Register multiple existing Auth Group accounts to the organization.
     * @param {Array<string>} body Array of Account Ids to be added
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async bulkWriteAccountsToOrg(body: Array<string>, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2014>> {
        return OrganizationUsersAccessApiFp(this.configuration).bulkWriteAccountsToOrg(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add multiple user accounts to multiple domains and roles. This is only an addition API and will not remove any roles or domains.
     * @summary Add multiple user accounts to multiple domains and roles
     * @param {OrgAccountsBody} body Updated access object
     * @param {string} group Auth Group Id or name
     * @param {string} org Organization id access is being applied to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async defineBulkUserAccessAdd(body: OrgAccountsBody, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20012>> {
        return OrganizationUsersAccessApiFp(this.configuration).defineBulkUserAccessAdd(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove multiple user accounts from multiple domains and roles. This is only a remove API and will not add any roles or domains.
     * @summary Remove multiple user accounts from multiple domains and roles
     * @param {OrgAccountsBody1} body Updated access object
     * @param {string} group Auth Group Id or name
     * @param {string} org Organization id access is being applied to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async defineBulkUserAccessRemove(body: OrgAccountsBody1, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20012>> {
        return OrganizationUsersAccessApiFp(this.configuration).defineBulkUserAccessRemove(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to change the domains and roles associated to an Account within the context of an Organization. Remember that this will overwrite the record not patch it.
     * @summary Overwrite defined user access of an Account in the context of a single Organization
     * @param {WriteAccess} body Updated access object
     * @param {string} group Auth Group Id or name
     * @param {string} org Organization id access is being applied to
     * @param {string} id id that need to be updated
     * @param {string} [notify] if notifications are enabled, you can override and skip them by setting this to false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async defineUserAccess(body: WriteAccess, group: string, org: string, id: string, notify?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<UpdateUserAccess>> {
        return OrganizationUsersAccessApiFp(this.configuration).defineUserAccess(body, group, org, id, notify, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Identify a single user associated to an organization. Remember that Account records only return create/modified/active metadata, an email and an id.
     * @summary Find a User with ID
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization ID
     * @param {string} id id of account type to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async getAccountByOrg(group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccount>> {
        return OrganizationUsersAccessApiFp(this.configuration).getAccountByOrg(group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This API allows you to browse the email and id of every user that has been added to your organization.
     * @summary Retrieve all users associated to an organization
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization ID
     * @param {string} [filter] oData filter Query
     * @param {string} [select] oData select Query
     * @param {string} [orderby] oData orderby Query
     * @param {string} [skip] oData skip Query
     * @param {string} [top] oData top Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async getAccountsByOrg(group: string, org: string, filter?: string, select?: string, orderby?: string, skip?: string, top?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAccounts>> {
        return OrganizationUsersAccessApiFp(this.configuration).getAccountsByOrg(group, org, filter, select, orderby, skip, top, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the specific record of domains and roles within the context of an organization. You can update and send back this record as part of the associated PUT endpoint to make changes.
     * @summary Get defined user access in order to make edits with PUT
     * @param {string} group Auth Group Id or name
     * @param {string} org Organization id access is being applied to
     * @param {string} id id that need to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async getDefinedUserAccess(group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<WriteAccess>> {
        return OrganizationUsersAccessApiFp(this.configuration).getDefinedUserAccess(group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint removes a user form an organization and cuts off all access immediately. Please be advised, if a user obtained access records as part ofa  JWT token, that token may still show access until it expires.
     * @summary Remove an organization from user's access
     * @param {string} group Auth Group Id or name
     * @param {string} org Organization id access is being applied to
     * @param {string} id id that need to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async removeOrgFromAccess(group: string, org: string, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserAccessAction>> {
        return OrganizationUsersAccessApiFp(this.configuration).removeOrgFromAccess(group, org, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to search accounts in the authgroup using a text search
     * @summary Search Accounts in the authGroup with an org context
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization context
     * @param {string} q keyword search
     * @param {string} [restrictEmail] restrict the search to specific email domains. comma dilimited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async searchAccountsFromOrg(group: string, org: string, q: string, restrictEmail?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2004>> {
        return OrganizationUsersAccessApiFp(this.configuration).searchAccountsFromOrg(group, org, q, restrictEmail, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If you intend to add or create a user specific to your organization, this is the correct API. You may want to use the account/search API first. This method will check to see if a user with the email specified exists. If the user exists, an organization access record will be added to that user's account, otherwise, the user is first created and then the access record added. This API does not allow you to set a password, one will be generated. If notifications are enabled (recommended), the caller will never see the password and a notification will be sent to the user or they can simply trigger a password reset to claim the account. If notifications are not enabled, the generated password will be returned with this call and include a warning that notifications are disabled. Please note that the only data provided by this endpoint (or any Account API) is the id, username, and email of the user within this AuthGroup. The Account record holds no personal information aside from this email address and an optional phone number which is only visible to that Account owner.
     * @summary Register a new or existing user as part of an organization
     * @param {WriteAccountByOrg} body Account data to be written
     * @param {string} group the auth group ID associated to your business account
     * @param {string} org the organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUsersAccessApi
     */
    public async writeAccountToOrg(body: WriteAccountByOrg, group: string, org: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse201>> {
        return OrganizationUsersAccessApiFp(this.configuration).writeAccountToOrg(body, group, org, options).then((request) => request(this.axios, this.basePath));
    }
}
